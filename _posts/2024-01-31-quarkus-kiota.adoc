---
layout: post
title: 'The road to generated SDKs with Kiota lands to Quarkus'
date: 2024-01-31
tags: release
synopsis: 'Introducing a Quarkus-Kiota extension and available Java tools to work with Kiota.'
author: andreaTP
---

== The challenge
:imagesdir: assets/images/posts/kiota

Quarkus applications are typically exposing functionalities through API's endpoints, here, we are going to discuss how to easily consume those APIs and provide a smooth experience to our beloved users.
HTTP calls are easy to be performed in any programming language and environment, still, when your API complexity starts to increase and the number of available endpoints becomes uncountable on the tip of your fingers you feel the urge of having better tools builds up.

image::api_monster.jpeg[API monster]

A fully typed programmatic API that makes discovering and invoking of the HTTP endpoints safe, expressive and elegant seems to ba good first step!
Looking at the learnings from big companies facing this issue at a scale, it becomes evident that a viable solution is to ship language-specifics SDKs(Software Development Kits).
For years now, those companies have been paying developers to manually provide an abstraction layer that makes the cloud services functionalities more easily accessible by developers coming from different backgrounds and using different programming languages.
This approach, pretty obviously, adds-up to the maintenance burden, increase the operational complexity of releases and, worst for us developers, is extremely tedious.

To pave the way for better tooling, as often happens in the computer industry, new standards are being defined.
For building HTTP based APIs, https://www.openapis.org[OpenAPI] stands out of the crowd as a widely adopted option.

The subtitle on the main page of their website cite, at the time of writing:

[subs="quotes"]
----
This allows people to understand how an API works, *generate client code*, create tests, apply design standards, and much, much more.
----

Perfect! That's what we are looking for!
There are multiple ways how you can define OpenAPI for the HTTP endpoints of your application, facilitating gradual adoption.
In this post we are not going to cover this aspect, and, from now on, we assume that you have an OpenAPI description of the server side component you are willing to talk to.

== Kiota to the rescue

Recognizing the challenges faced by the industry in generating comprehensive and efficient SDKs for diverse APIs, Microsoft took the lead, and, in the context of https://learn.microsoft.com/en-us/graph/overview[Microsoft Graph] introduced Kiota, an innovative open-source project, designed specifically to simplify and expedite the process of creating Software Development Kits (SDKs) for HTTP APIs.

Kiota's primary goal is to enhance the developer experience by offering a unified platform, promoting consistency and efficiency across various programming languages. With a focus on reducing the complexities associated with API integration, Kiota abstracts away most of the manual tasks involved in SDK development.

The project is characterized by its adaptability, supporting multiple programming languages and frameworks to accommodate a wide range of development environments. This flexibility ensures that developers can leverage Kiota regardless of their preferred technology stack, fostering a more inclusive and accessible development experience.

Kiota's commitment to open-source encourages collaboration and community engagement. Developers are invited to contribute, share feedback, and actively participate in shaping the evolution of this tool. As the landscape of APIs continues to evolve, Kiota stands as a valuable resource for developers seeking an efficient and standardized approach to SDK generation.

Nowadays, daily Kiota demonstrates its value with the automated generation of SDKs for multiple Microsoft's services and, more big industries like https://github.blog/2024-01-03-our-move-to-generated-sdks/[GitHub], are quickly following the lead.

== Red Hat collaboration

Deeply understanding the technological problem, accepting the fact that the available alternatives are sub-optimal especially for consistency across languages and frameworks, Red Hat joined the effort on Kiota with the aim of turning client SDKs generation into a boring technology everyone uses without even thinking about.

It's been a long journey, and there is a lot to write about, for now, I'll just mention a few important milestone that sprung from this collaboration:

- To make the usage of the generated code almost indistinguishable from a human crafted product we thoroughly implemented language-specific mangling of names
- Feeling the pain of un-maintained and various levels of maturity of URI Templates implementations (internally used to compose URLs) we rolled out a https://github.com/std-uritemplate/std-uritemplate?tab=readme-ov-file#motivation[dependency-free unified library] available for all of the languages Kiota supports
- To ease the fruition of the Kiota CLI from standard Java projects we implemented a https://github.com/kiota-community/kiota-java-extra?tab=readme-ov-file#maven-plugin[Maven plugin]
- To make frictionless the usage of Kiota on different and opinionated technological stacks we ship alternative core libraries to let the user easily swap out from Microsoft's defaults(OkHttp + Gson): https://github.com/kiota-community/kiota-java-extra?tab=readme-ov-file#serialization-jackson[Jackson Serde], https://github.com/kiota-community/kiota-java-extra?tab=readme-ov-file#http-vertx[Vert.X Http], https://github.com/kiota-community/kiota-java-extra?tab=readme-ov-file#http-jdk[JDK Http]
- To increase the compatibility with alternative Java runtimes we completely removed the usage of reflection from all of the internals, thus Kiota generated SDKs are automatically, and with 0 configuration able to be compiled and run on https://www.graalvm.org/latest/reference-manual/native-image/[GraalVM native-image]

Along with additional bug-fixes and improvements we finally achieved a sweet spot where Kiota can be easily integrated and leveraged by mainstream and mature software project, https://github.com/Apicurio/apicurio-registry[Apicurio Registry stands out among others] shipping(and extensively leveraging in tests) the generated https://github.com/Apicurio/apicurio-registry/tree/main/java-sdk[Java SDK] along with https://github.com/Apicurio/apicurio-registry/tree/main/python-sdk[Python] and https://github.com/Apicurio/apicurio-registry/tree/main/go-sdk[Go].

== Quarkus meet Kiota

Given the fact that all the dots have been already connected, the last, and most important step is a smooth integration with supersonic, subatomic applications leveraging Quarkus!
We are happy to announce that it has been finalized and you can swiftly leverage the power of Kiota thanks to the new `quarkus-kiota` extension!

The codebase lives in the https://github.com/quarkiverse/quarkus-kiota[Quarkiverse], the project is listed in the https://quarkus.io/extensions/io.quarkiverse.kiota/quarkus-kiota/[extensions] and the https://docs.quarkiverse.io/quarkus-kiota/dev/index.html[docs] are available at the usual location.

Get started by adding this extension:

----
quarkus ext add io.quarkiverse.kiota:quarkus-kiota
----

Since it's a code generator extension you will need to add the ``generate-code`` goal to the ``quarkus-maven-plugin`` ``executions`` section:

[source,xml]
----
<plugin>
  <groupId>io.quarkus</groupId>
  <artifactId>quarkus-maven-plugin</artifactId>
  <extensions>true</extensions>
  <executions>
    <execution>
      <goals>
        <goal>build</goal>
        <goal>generate-code</goal>
      </goals>
    </execution>
  </executions>
</plugin>
----

Add the necessary dependencies, we are going to replace the default http and json serialization libraries published by Microsoft and swap in Vert.X and Jackson(published from this https://github.com/kiota-community/kiota-java-extra[repository]) as they nicely play with the rest of the stack of a typical Quarkus based application.

[source,xml]
----
<dependency>
  <groupId>com.microsoft.kiota</groupId>
  <artifactId>microsoft-kiota-abstractions</artifactId>
  <version>${kiota.libs.version}</version>
</dependency>
<dependency>
  <groupId>io.kiota</groupId>
  <artifactId>kiota-http-vertx</artifactId> <!-- alternatively <artifactId>kiota-http-jdk</artifactId> -->
  <version>{kiota-java-extra.version}</version>
</dependency>
<dependency>
  <groupId>io.kiota</groupId>
  <artifactId>kiota-serialization-jackson-quarkus</artifactId>
  <version>{kiota-java-extra.version}</version>
</dependency>
<dependency>
  <groupId>com.microsoft.kiota</groupId>
  <artifactId>microsoft-kiota-serialization-text</artifactId>
  <version>${kiota.libs.version}</version>
</dependency>
<dependency>
  <groupId>com.microsoft.kiota</groupId>
  <artifactId>microsoft-kiota-serialization-form</artifactId>
  <version>${kiota.libs.version}</version>
</dependency>
<dependency>
  <groupId>com.microsoft.kiota</groupId>
  <artifactId>microsoft-kiota-serialization-multipart</artifactId>
  <version>${kiota.libs.version}</version>
</dependency>
<dependency>
  <groupId>jakarta.annotation</groupId>
  <artifactId>jakarta.annotation-api</artifactId>
</dependency>
----

Now we need to generate the actual client for our OpenAPI description, to do so, you should drop the OpenAPI file in the ``src/main/openapi`` folder.
You are all set to use the client in your application:

[source,java]
----
var client = new ApiClient(ew VertXRequestAdapter(vertx));
client.
----

after typing `.` after client, the code completion of your IDE should kick in and provide you a beautiful, fully typed, builder pattern matching the endopoint descriptions provided in the OpenAPI specification.

For example an endpoint definition like https://github.com/Apicurio/apicurio-registry/blob/6882af10e9de8e1d245006db01f039b1fbf6355a/common/src/main/resources/META-INF/openapi-v2.json#L668[this one] nicely unroll in Java as:

[source,java]
----
client
  .groups()
  .byGroupId(groupId)
  .artifacts()
  .byArtifactId(artifactId)
  .meta()
  .get();
----

== Alternatives

Among the various alternatives https://github.com/quarkiverse/quarkus-openapi-generator[``quarkus-openapi-generator``] is a mature Quarkus extension to generate client code from OpenAPI, we warmly encourage you to use it when you want to favor a tight Quarkus integration as opposed to consistency across languages/frameworks.

== Come Join Us

We value your feedback a lot so please report bugs, ask for improvements... Let's build something great together!

If you are a Quarkus-Kiota user or just curious, don't be shy and join our welcoming community:

 * provide feedback on https://github.com/quarkiverse/quarkus-kiota/issues[GitHub];
 * craft some code and https://github.com/quarkiverse/quarkus-kiota/pulls[push a PR];
 